---
title: 回文自动机初探
date: 2017-06-02 20:56:29
tags: [回文自动机,随笔]
---

<!--more-->

回文自动机是一个树形结构,利用类似Trie的存储方式来存储.它包含四个内容:

```cpp
struct PAM{
  int to[N][26],f[N],len[N],right[N],last,cnt;
  PAM(){len[1]=-1;f[0]=cnt=1;}
}
```

其中:

- 后缀自动机的每一个状态都代表了原串的一个回文子串.

- to数组表示转移,to[x][c]表示在自动机上的状态x所代表的回文串两边接上c这个字符,会转移到的状态.
 
- f数组表示失配,f[x]表示状态x所代表的回文串的最长**回文后缀**所在的状态.
 
- len数组表示长度,len[x]表示状态x所代表的回文串的长度.
 
- right数组表示次数,right[x]表示状态x所代表的回文串在原串中出现过多少次.
 
- cnt是回文自动机的状态总数,last表示原串的**最大回文后缀**所在的状态.
 
- 0状态以及它的后续状态表示了所有长度为**偶数**的回文子串,1状态以及它的后续状态表示了所有长度为**奇数**的回文子串.特殊的:len[1]=-1,f[0]=1.
 
上述是回文自动机的基本原理的重要部分.

回文自动机的构建方法与后缀自动机类似,采用增量法构建:

```cpp
void extend(int c,int n){
  int p=last;
  while(ch[n]!=ch[n-len[p]-1]) p=f[p];
  if(!to[p][c]){
    int np=++cnt,k=f[p];len[np]=len[p]+2;
    while(ch[n]!=ch[n-len[k]-1]) k=f[k];
    f[np]=to[k][c];to[p][c]=np;
  }
  right[last=to[p][c]]++;
}
```

函数extend(c,n)表示在长度为n-1的原串ch的回文自动机后加上一个字符c.

首先提出一个引理:在原字符串后添加一个字符,所新增的**本质不同的回文后缀的个数**最多只有一个.

考虑增量法的步骤:

- 先找到ch的一个**极长回文后缀**,满足这个回文后缀之前的那个字符与c相等.应当从状态last沿着f数组向上找.假设找到的状态为p.

- 如果p有一个转移to[p][c],则可以直接结束,因为根据引理,ch+c的**所有**回文串在这个回文自动机中都存在了.

- 如果p没有转移to[p][c],则新建一个状态np,将p的to[p][c]指向np,np的len为p的len+2(显然).现在需要考虑np的f是什么,可以从p开始沿着f数组向上找,直到找到一个状态使得这个状态表示的**回文后缀**(因为p是ch的回文后缀,所以在这里找到的状态仍然是ch的回文后缀)之前的那个字符与c相等,设这个状态为k,那么就令f[np]=to[k][c].

至此,回文自动机构建完毕,总的复杂度为均摊后的$O(n)$.

最后right数组要利用回文自动机的拓扑序来DP求解:

```cpp
void calcright(){
  for(int i=cnt;i>=0;i--) right[f[i]]+=right[i];
}
```